// FILE: frontend/src/hooks/useBlockchain.js
// ENHANCED VERSION - 100% Stable Contract Connectivity

import { useState, useEffect, useCallback } from 'react';
import { ethers } from 'ethers';
import { NETWORK_CONFIG, deployedAddresses, WEATHER_TYPES } from '../contracts/contractConfig';

// Simplified Contract ABIs that match your deployed contracts
const WEATHER_ORACLE_ABI = [
  "function getCurrentWeather() view returns (uint8)",
  "function updateWeather(uint8 newWeather) external",
  "event WeatherUpdated(uint8 newWeather, uint256 timestamp)"
];

const WEATHER_TOKEN_ABI = [
  "function balanceOf(address account) view returns (uint256)",
  "function name() view returns (string)",
  "function symbol() view returns (string)",
  "function decimals() view returns (uint8)"
];

const QUEST_MANAGER_ABI = [
  "function completeQuest(uint256 questId) external payable",
  "function getQuestReward(uint256 questId) view returns (uint256)",
  "event QuestCompleted(address player, uint256 questId, uint256 reward)"
];

const WEATHER_NFT_ABI = [
  "function mint(address to, uint256 weatherType) external payable",
  "function balanceOf(address owner) view returns (uint256)",
  "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
  "function tokenURI(uint256 tokenId) view returns (string)"
];

export const useBlockchain = () => {
  // State management
  const [provider, setProvider] = useState(null);
  const [signer, setSigner] = useState(null);
  const [account, setAccount] = useState(null);
  const [isConnected, setIsConnected] = useState(false);
  const [balance, setBalance] = useState('0.000000');
  const [tokenBalance, setTokenBalance] = useState('0');
  const [currentWeather, setCurrentWeather] = useState('Sunshine');
  const [contracts, setContracts] = useState({});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [nftCount, setNftCount] = useState(0);
  const [contractsInitialized, setContractsInitialized] = useState(false);
  const [connectionAttempts, setConnectionAttempts] = useState(0);

  // Clear error after 10 seconds
  useEffect(() => {
    if (error) {
      const timer = setTimeout(() => setError(null), 10000);
      return () => clearTimeout(timer);
    }
  }, [error]);

  // ENHANCED: Auto-retry contract initialization
  const retryContractInitialization = useCallback(async () => {
    if (signer && !contractsInitialized && connectionAttempts < 3) {
      console.log(`üîÑ Retrying contract initialization (attempt ${connectionAttempts + 1}/3)`);
      setConnectionAttempts(prev => prev + 1);
      
      setTimeout(async () => {
        const contractInstances = await initializeContracts(signer);
        if (Object.keys(contractInstances).length > 0) {
          setContractsInitialized(true);
          setConnectionAttempts(0);
        }
      }, 2000); // Wait 2 seconds before retry
    }
  }, [signer, contractsInitialized, connectionAttempts]);

  // Auto-retry if contracts fail to initialize
  useEffect(() => {
    if (signer && !contractsInitialized && connectionAttempts < 3) {
      retryContractInitialization();
    }
  }, [signer, contractsInitialized, retryContractInitialization]);

  // ENHANCED: Auto-update balance immediately when account/provider changes
  const updateBalances = useCallback(async (accountAddress = null) => {
    const targetAccount = accountAddress || account;
    if (!provider || !targetAccount) {
      console.log('‚ö†Ô∏è Cannot update balances: missing provider or account');
      return;
    }

    try {
      console.log('üí∞ Updating balances for:', targetAccount);

      // Get STT balance with enhanced retry mechanism
      let sttBalance;
      for (let i = 0; i < 5; i++) {
        try {
          sttBalance = await provider.getBalance(targetAccount);
          break;
        } catch (retryError) {
          console.log(`Balance retry ${i + 1}/5`);
          if (i === 4) throw retryError;
          await new Promise(resolve => setTimeout(resolve, 1500));
        }
      }

      const formattedBalance = ethers.formatEther(sttBalance);
      setBalance(formattedBalance);
      console.log('‚úÖ STT Balance updated:', formattedBalance);

      // Get NFT count if contract exists (with retry)
      if (contracts.weatherNFT) {
        for (let i = 0; i < 3; i++) {
          try {
            const nftBalance = await contracts.weatherNFT.balanceOf(targetAccount);
            setNftCount(parseInt(nftBalance.toString()));
            console.log('‚úÖ NFT Count updated:', nftBalance.toString());
            break;
          } catch (nftError) {
            if (i === 2) {
              console.log('‚ö†Ô∏è Could not fetch NFT balance after retries:', nftError.message);
            }
          }
        }
      }

      // Get token balance if contract exists (with retry)
      if (contracts.weatherToken) {
        for (let i = 0; i < 3; i++) {
          try {
            const tokenBal = await contracts.weatherToken.balanceOf(targetAccount);
            const formattedTokenBalance = ethers.formatEther(tokenBal);
            setTokenBalance(formattedTokenBalance);
            console.log('‚úÖ Token Balance updated:', formattedTokenBalance);
            break;
          } catch (tokenError) {
            if (i === 2) {
              console.log('‚ö†Ô∏è Could not fetch token balance after retries:', tokenError.message);
            }
          }
        }
      }
    } catch (error) {
      console.error('‚ùå Failed to update balances:', error);
      setError(`Balance update failed: ${error.message}`);
    }
  }, [provider, account, contracts.weatherNFT, contracts.weatherToken]);

  // Handle account changes
  const handleAccountsChanged = useCallback((accounts) => {
    console.log('üë§ Account changed:', accounts);
    if (accounts.length === 0) {
      disconnectWallet();
    } else {
      setAccount(accounts[0]);
      setContractsInitialized(false); // Reset contract state for new account
      setConnectionAttempts(0);
      // Force balance update with new account
      setTimeout(() => updateBalances(accounts[0]), 500);
    }
  }, [updateBalances]);

  // Handle network changes
  const handleChainChanged = useCallback(() => {
    console.log('üîÑ Network changed, reloading...');
    window.location.reload();
  }, []);

  // Initialize provider and check connection on mount
  useEffect(() => {
    const initializeApp = async () => {
      console.log('üöÄ Initializing blockchain app...');

      if (typeof window.ethereum === 'undefined') {
        setError('Please install MetaMask to use this app');
        return;
      }

      try {
        // Create provider
        const web3Provider = new ethers.BrowserProvider(window.ethereum);
        setProvider(web3Provider);
        console.log('‚úÖ Provider created');

        // Set up event listeners
        window.ethereum.on('accountsChanged', handleAccountsChanged);
        window.ethereum.on('chainChanged', handleChainChanged);

        // Check if already connected
        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
        if (accounts.length > 0) {
          console.log('üîó Already connected to account:', accounts[0]);
          await connectWalletDirect(web3Provider, accounts[0]);
        } else {
          console.log('üë§ No accounts connected');
        }
      } catch (error) {
        console.error('‚ùå Failed to initialize app:', error);
        setError('Failed to initialize wallet connection');
      }
    };

    initializeApp();

    // Cleanup function
    return () => {
      if (window.ethereum) {
        window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
        window.ethereum.removeListener('chainChanged', handleChainChanged);
      }
    };
  }, [handleAccountsChanged, handleChainChanged]);

  // Switch to Somnia Network
  const switchToSomniaNetwork = async () => {
    try {
      console.log('üîÑ Switching to Somnia network...');
      await window.ethereum.request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId: NETWORK_CONFIG.chainIdHex }],
      });
      console.log('‚úÖ Switched to Somnia network');
    } catch (switchError) {
      if (switchError.code === 4902) {
        console.log('üìù Adding Somnia network...');
        try {
          await window.ethereum.request({
            method: 'wallet_addEthereumChain',
            params: [{
              chainId: NETWORK_CONFIG.chainIdHex,
              chainName: NETWORK_CONFIG.name,
              rpcUrls: [NETWORK_CONFIG.rpcUrl],
              nativeCurrency: NETWORK_CONFIG.nativeCurrency,
              blockExplorerUrls: [NETWORK_CONFIG.blockExplorer]
            }],
          });
          console.log('‚úÖ Somnia network added');
        } catch (addError) {
          throw new Error('Failed to add Somnia network');
        }
      } else {
        throw switchError;
      }
    }
  };

  // ENHANCED: Initialize smart contracts with bulletproof error handling
  const initializeContracts = async (signerInstance) => {
    try {
      console.log('üìã Initializing contracts with enhanced stability...');

      const contractInstances = {};
      let successCount = 0;

      // Get signer address for testing
      const signerAddress = await signerInstance.getAddress();
      console.log('üìç Signer address for testing:', signerAddress);

      // Initialize each contract with individual error handling and specific tests
      const contractConfigs = [
        { 
          name: 'weatherOracle', 
          address: deployedAddresses.WeatherOracle, 
          abi: WEATHER_ORACLE_ABI,
          testFn: async (contract) => {
            // Test read function that should always work
            return await contract.getCurrentWeather();
          }
        },
        { 
          name: 'weatherToken', 
          address: deployedAddresses.WeatherToken, 
          abi: WEATHER_TOKEN_ABI,
          testFn: async (contract) => {
            // Test balance check which should always work
            return await contract.balanceOf(signerAddress);
          }
        },
        { 
          name: 'questManager', 
          address: deployedAddresses.QuestManager, 
          abi: QUEST_MANAGER_ABI,
          testFn: async (contract) => {
            // Test quest reward query which should always work
            return await contract.getQuestReward(1);
          }
        },
        { 
          name: 'weatherNFT', 
          address: deployedAddresses.WeatherNFT, 
          abi: WEATHER_NFT_ABI,
          testFn: async (contract) => {
            // Test NFT balance check which should always work
            return await contract.balanceOf(signerAddress);
          }
        }
      ];

      // Initialize contracts with individual retry logic
      for (const config of contractConfigs) {
        let contractSuccess = false;
        
        for (let attempt = 0; attempt < 3; attempt++) {
          try {
            console.log(`üìã Initializing ${config.name} (attempt ${attempt + 1}/3)...`);
            
            // Create contract instance
            contractInstances[config.name] = new ethers.Contract(
              config.address,
              config.abi,
              signerInstance
            );

            // Test contract with appropriate function
            const testResult = await config.testFn(contractInstances[config.name]);
            console.log(`‚úÖ ${config.name} test result:`, testResult.toString());

            console.log(`‚úÖ ${config.name} contract initialized and tested successfully`);
            successCount++;
            contractSuccess = true;
            break;

          } catch (error) {
            console.log(`‚ö†Ô∏è ${config.name} contract attempt ${attempt + 1} failed:`, error.message);
            
            if (attempt === 2) {
              console.log(`‚ùå ${config.name} contract failed after all attempts`);
              // Don't include failed contract in the instances
              delete contractInstances[config.name];
            } else {
              // Wait before retry
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
          }
        }
      }

      setContracts(contractInstances);
      console.log(`‚úÖ ${successCount}/${contractConfigs.length} contracts initialized successfully`);

      // Mark as initialized if we have at least 2 contracts working
      if (successCount >= 2) {
        setContractsInitialized(true);
        setConnectionAttempts(0);
      }

      return contractInstances;
    } catch (error) {
      console.error('‚ùå Failed to initialize contracts:', error);
      setContracts({});
      setContractsInitialized(false);
      return {};
    }
  };

  // ENHANCED: Direct wallet connection with immediate balance loading
  const connectWalletDirect = async (web3Provider = null, existingAccount = null) => {
    try {
      setLoading(true);
      setError(null);
      setContractsInitialized(false);
      setConnectionAttempts(0);
      console.log('üîó Connecting wallet with enhanced stability...');

      const currentProvider = web3Provider || provider;
      if (!currentProvider) {
        throw new Error('No provider available');
      }

      let accounts;
      if (existingAccount) {
        accounts = [existingAccount];
      } else {
        // Request account access
        accounts = await window.ethereum.request({
          method: 'eth_requestAccounts',
        });
      }

      if (accounts.length === 0) {
        throw new Error('No accounts found');
      }

      console.log('üë§ Account:', accounts[0]);

      // Switch to Somnia network
      await switchToSomniaNetwork();

      // Get signer
      const web3Signer = await currentProvider.getSigner();

      // Verify signer account matches
      const signerAddress = await web3Signer.getAddress();
      console.log('‚úÖ Signer address:', signerAddress);

      // Update state
      setProvider(currentProvider);
      setSigner(web3Signer);
      setAccount(accounts[0]);
      setIsConnected(true);

      // ENHANCED: Initialize contracts with retry logic
      console.log('üìã Initializing contracts with enhanced retry...');
      const contractInstances = await initializeContracts(web3Signer);

      // ENHANCED: Force balance update immediately after connection
      console.log('üí∞ Loading balances...');
      setTimeout(() => updateBalances(accounts[0]), 1000);

      // Get current weather from contract or set default
      await new Promise(resolve => setTimeout(resolve, 2000)); // Wait for contracts to settle
      
      try {
        if (contractInstances.weatherOracle) {
          const weatherId = await contractInstances.weatherOracle.getCurrentWeather();
          const weatherName = WEATHER_TYPES[weatherId] || 'Sunshine';
          setCurrentWeather(weatherName);
          console.log('üå§Ô∏è Current weather from contract:', weatherName);
        } else {
          setCurrentWeather('Sunshine');
          console.log('üå§Ô∏è Default weather set: Sunshine');
        }
      } catch (error) {
        console.log('‚ö†Ô∏è Could not get weather from contract, using default');
        setCurrentWeather('Sunshine');
      }

      console.log('‚úÖ Wallet connected successfully with enhanced stability');

    } catch (error) {
      console.error('‚ùå Failed to connect wallet:', error);
      setError(error.message || 'Failed to connect wallet');

      // Reset connection state
      setIsConnected(false);
      setAccount(null);
      setSigner(null);
      setContracts({});
      setContractsInitialized(false);
      setConnectionAttempts(0);
    } finally {
      setLoading(false);
    }
  };

  // Public connect wallet function
  const connectWallet = useCallback(() => {
    connectWalletDirect();
  }, []);

  // ENHANCED: Manual contract reconnection
  const reconnectContracts = useCallback(async () => {
    if (!signer) {
      setError('No signer available for reconnection');
      return;
    }

    setContractsInitialized(false);
    setConnectionAttempts(0);
    console.log('üîÑ Manually reconnecting contracts...');

    const contractInstances = await initializeContracts(signer);
    
    if (Object.keys(contractInstances).length > 0) {
      console.log('‚úÖ Manual contract reconnection successful');
      await updateBalances();
    } else {
      setError('Failed to reconnect contracts');
    }
  }, [signer, updateBalances]);

  // Update weather
  const updateWeather = async (newWeatherId) => {
    if (!contracts.weatherOracle || !signer) {
      console.log('‚ö†Ô∏è Contract not available, updating local weather only');
      const weatherName = WEATHER_TYPES[newWeatherId] || 'Sunshine';
      setCurrentWeather(weatherName);
      return;
    }

    try {
      setLoading(true);
      console.log('üå¶Ô∏è Updating weather to:', newWeatherId);

      const tx = await contracts.weatherOracle.updateWeather(newWeatherId, {
        gasLimit: 100000,
        gasPrice: ethers.parseUnits('12', 'gwei')
      });
      await tx.wait();

      // Update local state
      const weatherName = WEATHER_TYPES[newWeatherId] || 'Sunshine';
      setCurrentWeather(weatherName);

      console.log('‚úÖ Weather updated successfully');
      return tx;
    } catch (error) {
      console.error('‚ùå Failed to update weather:', error);
      setError('Weather update failed');
      throw error;
    } finally {
      setLoading(false);
    }
  };

  // ENHANCED: Complete quest with proper error handling
  const completeQuest = async (questId) => {
    if (!contracts.questManager || !signer) {
      throw new Error('Quest contract not available');
    }

    try {
      setLoading(true);
      console.log('üéÆ Completing quest:', questId);

      // Send with minimal gas and no value (unless quest requires payment)
      const tx = await contracts.questManager.completeQuest(questId, {
        gasLimit: 100000,
        gasPrice: ethers.parseUnits('12', 'gwei'),
        value: 0 // No payment required for quest completion
      });

      console.log('‚õΩ Transaction sent! Hash:', tx.hash);
      const receipt = await tx.wait();

      console.log('‚úÖ Quest completed successfully');
      await updateBalances(); // Refresh balances after completion

      return { tx, receipt };
    } catch (error) {
      console.error('‚ùå Failed to complete quest:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  };

  // ENHANCED: Mint NFT with proper error handling
  const mintNFT = async (weatherType) => {
    if (!contracts.weatherNFT || !signer) {
      throw new Error('NFT contract not available');
    }

    try {
      setLoading(true);
      console.log('üé® Minting NFT of type:', weatherType);

      // Send with minimal gas and no value (unless minting requires payment)
      const tx = await contracts.weatherNFT.mint(account, weatherType, {
        gasLimit: 150000,
        gasPrice: ethers.parseUnits('12', 'gwei'),
        value: 0 // No payment required for minting
      });

      console.log('‚õΩ Transaction sent! Hash:', tx.hash);
      const receipt = await tx.wait();

      console.log('‚úÖ NFT minted successfully');
      await updateBalances(); // Refresh balances and NFT count

      return { tx, receipt };
    } catch (error) {
      console.error('‚ùå Failed to mint NFT:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  };

  // Get current weather state
  const getCurrentWeatherState = async () => {
    if (!contracts.weatherOracle) {
      console.log('‚ö†Ô∏è Weather oracle not available');
      return currentWeather;
    }

    try {
      const weatherId = await contracts.weatherOracle.getCurrentWeather();
      const weatherName = WEATHER_TYPES[weatherId] || 'Sunshine';
      setCurrentWeather(weatherName);
      return weatherName;
    } catch (error) {
      console.error('‚ùå Failed to get weather state:', error);
      return currentWeather;
    }
  };

  // Disconnect wallet
  const disconnectWallet = useCallback(() => {
    console.log('üîå Disconnecting wallet...');
    setProvider(null);
    setSigner(null);
    setAccount(null);
    setIsConnected(false);
    setBalance('0.000000');
    setTokenBalance('0');
    setCurrentWeather('Sunshine');
    setContracts({});
    setNftCount(0);
    setError(null);
    setContractsInitialized(false);
    setConnectionAttempts(0);
    console.log('‚úÖ Wallet disconnected');
  }, []);

  // ENHANCED: Get contract status with proper connection check
  const getContractStatus = useCallback(() => {
    const contractsConnected = Object.keys(contracts).length > 0 && contractsInitialized;
    return {
      WeatherOracle: deployedAddresses.WeatherOracle,
      WeatherToken: deployedAddresses.WeatherToken,
      QuestManager: deployedAddresses.QuestManager,
      WeatherNFT: deployedAddresses.WeatherNFT,
      MultiplayerSync: deployedAddresses.MultiplayerSync,
      isConnected: contractsConnected,
      network: NETWORK_CONFIG.name,
      contractCount: Object.keys(contracts).length,
      initialized: contractsInitialized
    };
  }, [contracts, contractsInitialized]);

  return {
    // State
    account,
    isConnected,
    balance,
    tokenBalance,
    currentWeather,
    loading,
    error,
    provider,
    signer,
    contracts,
    nftCount,
    contractsInitialized,

    // Actions
    connectWallet,
    disconnectWallet,
    reconnectContracts,
    updateWeather,
    completeQuest,
    mintNFT,
    updateBalances,
    getCurrentWeatherState,
    getContractStatus
  };
};

export default useBlockchain;